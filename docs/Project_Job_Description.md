좋아. 지금까지의 프로젝트 개요와 네가 제공한 실행 환경 및 사용자를 바탕으로, 파일 이름 클린, API 검색, 파일 이동/분류, 고급 기능(머신러닝 파서, 캐시 DB, 플러그인 아키텍처 등)을 모듈 단위로 정리하고,

각 작업 항목의 세부 업무 분해, 모듈 간 인터페이스 정의, 예외 처리, 통합 계획, 최신 기술 동향 기반 개선 사항을 포함한 전체 업무 지시서를 준비할게. 작업이 완료되면 바로 공유할게.

# 애니메이션 파일 자동 분류기 프로젝트 업무 지시서

## 프로젝트 개요
이 프로젝트는 사용자가 다운로드한 애니메이션 영상 파일들과 자막 파일들을 자동으로 정리하는 Python 기반 도구 개발을 목표로 한다. PyQt5로 구현된 단일 GUI를 통해 사용자는 복잡한 파일명을 **정제(클린업)**하여 메타데이터를 조회하고, 해당 정보를 바탕으로 정해진 폴더 구조에 따라 파일을 **자동 분류**할 수 있다. 파일명 자체는 변경하지 않고 그대로 유지하면서 폴더만 정리하며, 영상 파일과 동일한 자막 파일(`.srt`, `.ass` 등)도 함께 이동시켜 연동된다.  

본 프로그램은 Windows 11 환경의 Python 3.12로 개발되며, 초기에는 개발자 개인 사용을 위해 만들지만 이후 일반 사용자들도 활용할 수 있도록 exe 형태로 배포될 가능성을 고려한다. 주 사용자층은 다운로드 받은 애니메이션 파일을 체계적으로 관리하고자 하는 **일반인**부터 **파워 유저**까지이며, 복잡한 설정 없이도 손쉽게 파일 정리에 활용할 수 있는 직관적 인터페이스를 제공하는 것을 지향한다.

## 목표 및 주요 기능
이 프로젝트의 주요 목표는 **메타데이터 기반의 자동 파일 정리**이며, 이를 구현하기 위한 필수 기능은 다음과 같다:

- **파일명 클리너**: 영상 파일명의 불필요한 정보를 제거하고 작품명, 화수 등의 핵심 정보를 추출한다. 초기 버전에서는 정규표현식 패턴 매칭을 사용하고, 차후 머신러닝 모델을 도입해 더욱 지능적으로 파일명을 해석할 수 있도록 설계한다.  
- **메타데이터 검색 API 클라이언트**: 정제된 작품명을 바탕으로 TMDB의 API를 호출하여 작품의 메타데이터(예: 원제목, 출시연도, 장르 등)를 가져온다. 구조적으로 AniDB, MyAnimeList(MAL) 등 다른 API로 쉽게 확장할 수 있도록 모듈화하여 설계한다.  
- **파일 분류기**: 얻어진 메타데이터에 따라 지정된 폴더 구조 (예: `출시연도/주요장르/작품명`)를 생성하고, 해당 폴더로 영상 파일을 이동시킨다. 이때 파일명은 변경하지 않고 유지하며, 동일한 이름의 자막 파일도 함께 이동시켜 영상과 동일 폴더에 배치한다.  
- **캐시 데이터베이스**: 동일한 시리즈에 대해 반복적인 API 검색을 피하기 위해 SQLite 기반의 캐시 DB를 구축한다. 이미 한 번 메타데이터를 조회한 시리즈는 DB에 정보를 저장해두고 이후에는 API 호출 없이 캐시된 정보를 활용한다.  
- **플러그인 아키텍처**: 메타데이터 소스 추가, 분류 규칙 변경, UI 기능 확장 등이 용이하도록 플러그인 구조로 설계한다. 예를 들어, TMDB 이외에 AniDB나 MAL을 플러그인으로 추가하거나, 폴더 분류 정책을 커스텀 플러그인으로 교체할 수 있으며, 나아가 UI에 새로운 탭을 추가하는 등의 확장이 가능하도록 유연성을 확보한다.

## 시스템 구성 및 모듈 설계
본 도구는 상기 기능들을 각각 모듈화하여 구성한다. **PyQt5 기반 UI 모듈**이 전체 흐름을 통제하며, 사용자의 명령에 따라 개별 모듈을 순차적으로 호출하는 구조를 갖는다. 각 모듈은 명확한 역할 분담을 가지며, 모듈 간 데이터 인터페이스를 통해 유기적으로 동작한다. 전체적인 처리 흐름은 다음과 같다:

1. **파일 선택**: 사용자가 UI에서 정리하고자 하는 영상 파일(들)이 있는 디렉토리를 선택한다.
1.5 **비슷한 파일 묶음**: 폴더 파일 리스트를 작성 중 비슷한 작품명(나루토 01, 나루토 02, 나루토 03) 들을 각각 동일 리스트에 묶어 검색 효율성을 늘린다.
2. **파일명 정제**: 선택된 각 파일에 대해 파일명 클리너 모듈이 동작하여 작품명, 화수 등의 정보를 추출하고 불필요한 문자열을 제거한다.
3. **메타데이터 조회**: 정제된 이름을 API 클라이언트 모듈에 전달하여 TMDB 등 온라인 DB에서 작품 메타데이터를 검색한다. 검색 전 캐시 DB를 조회하여 이미 처리한 적 있는 작품이면 API 대신 캐시 데이터를 활용한다.  
4. **폴더 경로 결정**: 검색된 메타데이터(출시연도, 장르, 작품명 등)에 따라 파일을 이동시킬 대상 경로를 결정한다. 분류 모듈이 지정된 규칙(예: `연도/장르/제목`)에 따라 폴더 구조를 만들고 경로를 생성한다.  
5. **파일 이동**: 파일 분류 모듈이 원본 영상 파일을 결정된 폴더로 이동시키고, 동일한 이름의 자막 파일이 존재하면 함께 이동시킨다. 이때 이미 해당 작품 폴더가 생성되어 있다면 새로운 파일만 추가로 넣는다.  
6. **결과 처리 및 반복**: 한 파일의 처리가 완료되면, UI에 진행 상황을 갱신하고 다음 파일을 처리한다. 모든 파일에 대한 작업이 끝나면 사용자에게 최종 결과(정리된 파일 개수, 실패 내역 등)를 보여준다.  

이러한 흐름을 뒷받침하는 주요 모듈들을 상세 설계하면 다음과 같다.

### 파일명 정리 모듈 (Filename Cleaner)
**역할**: 원본 영상 파일명의 노이즈(noise)를 제거하고 **작품명**과 **에피소드 정보**를 추출한다. 팬섭 그룹명, 화질 및 인코딩 정보(예: `[Ohys-Raws]`, `1080p`, `x264` 등), 릴리즈 번호나 불필요한 태그를 제거하여 깨끗한 형태의 제목을 얻는 것이 목표다. 이 모듈의 출력은 검색에 사용될 **정제된 제목 문자열** (및 가능하다면 에피소드 번호나 시즌 정보)이다. 파일명 자체는 디스크에서 변경하지 않으며, 이 단계의 처리는 메타데이터 검색을 위한 메모리 상의 문자열 조작에 한정된다.

**세부 구현**:
- 일반적인 애니메이션 파일명 패턴을 분석하여 정규표현식(Regex) 패턴 세트를 작성한다. 예를 들어, `\[.*\]` 형태로 팬섭 그룹명을 제거하고, `\d+p`로 해상도 표시를 제거하며, `EP?\d+`로 에피소드 번호를 인식하는 등의 패턴을 포함한다. 이러한 패턴 적용 순서와 예외 사항을 체계화하여 다양한 형태의 파일명에 대응한다.
- 정규표현식으로 제거하기 어려운 복잡한 패턴이나 오탈자 등에 대비해, 추후 머신러닝 기반 모델을 적용할 수 있도록 구조를 마련한다. 예를 들어, LSTM이나 Transformer 기반의 **시퀀스 레이블링** 모델을 훈련시켜 파일명 문자열에서 제목과 부가 정보를 구분하는 방식도 고려한다. 초기 버전에서는 Regex로 구현하되, ML 모델 적용을 위해 해당 모듈의 인터페이스를 단순화하여 교체가 쉽도록 설계한다.
- 정제 과정에서 얻은 **작품명**과 **에피소드 번호** 등을 별도의 객체나 딕셔너리로 반환한다. 예를 들어 `{ title: "Attack on Titan", episode: 1, season: 4 }` 형태로 구조화할 수 있다. 에피소드 정보까지 정확히 추출하기 어려운 경우 최소한 작품명 문자열만이라도 정확히 추출하는 것을 목표로 한다.
- 혹시 파일명에 여러 에피소드가 포함된 경우(예: 한 파일에 1~2화가 같이 있는 경우)나 특수 케이스(OVA, 극장판 등의 별도 표시)는 별도의 처리 규칙을 마련한다. 이러한 경우 작품명만 추출하고 에피소드 정보는 None으로 둘 수도 있다.
- **작업 목록**:
  - 파일명 정제용 정규표현식 패턴 정의 및 테스트 (여러 사례별로).
  - 파일명 파싱 함수 구현: 입력으로 파일명을 받아 클린한 작품명 및 에피소드 정보를 반환.
  - 여러 패턴을 순차 적용하고 남은 문자열을 트림(trim)하여 최종 결과 산출.
  - 파싱 실패 또는 불확실한 경우 예외 처리: 결과를 빈 값이 아닌 원본 이름으로 그대로 넘기도록 하여 검색 시 최소한 원본 이름이라도 활용하게 한다.
  - 모듈 단위 테스트: 다양한 파일명 입력에 대해 예상되는 정제 결과가 나오는지 검증.
- **인터페이스 및 의존성**: 이 모듈은 파일 경로(혹은 파일명 문자열)를 입력받아 정제된 문자열 데이터를 출력한다. 다른 모듈과의 의존은 없고, 순수 문자 처리 기능으로 자체 완결적이어야 한다. UI나 메인 프로세스는 이 모듈을 호출하여 얻은 문자열을 이후 API 검색에 사용한다.
- **예외 처리**: 예상치 못한 형식의 파일명으로 인해 Regex가 매칭되지 않거나 잘못 잘라낼 경우, 해당 파일명을 건너뛰거나 원본명을 그대로 반환한다. 오류가 발생해도 전체 프로세스를 중단하지 않고 로그로 남겨 사용자에게 알리도록 한다. 추후 ML 모델 적용 시에는 모델의 출력 신뢰도가 낮을 경우(예: 확신도가 일정 임계치 미만) fallback으로 기존 Regex 방식을 사용하는 식의 이중 장치를 마련한다.

### 메타데이터 검색 모듈 (TMDB/AniDB API Client)
**역할**: 앞 단계에서 얻은 작품명 (및 부가 정보)을 사용하여 **온라인 메타데이터 DB**에서 해당 작품의 정보를 가져온다. 초기 구현에서는 **TMDB API**를 사용하며, 이후 필요에 따라 AniDB, MyAnimeList API 등으로 확장 가능한 구조로 개발한다. 이 모듈은 검색어를 구성하고 API 호출을 수행한 뒤, 결과로부터 **작품의 메타데이터**(출시연도, 장르, 작품 정식명 등)를 추출하여 반환한다.

**세부 구현**:
- **TMDB API 연동**: TMDB는 영화와 TV 시리즈에 대한 방대한 데이터를 제공하므로, 애니메이션 TV 시리즈는 TV 섹션에서 검색하고 극장판 애니메이션은 영화 섹션에서 검색하는 방식으로 활용한다. TMDB의 Search API를 사용하여 작품명을 질의하고, 응답 JSON에서 가장 연관성 높은 결과를 선택한다. (필요시 응답에 여러 결과가 있을 경우, 출시연도나 매칭 점수를 활용해 **최적 결과**를 선택하는 알고리즘을 포함한다.)
- **TMDB 결과 처리**: 선택된 결과로부터 필요한 세부 정보를 가져오기 위해 TMDB의 상세 정보 API를 추가 호출한다. 예를 들어 TV 시리즈인 경우 `tv/{id}` 엔드포인트를 호출해 **첫 방영연도**(first_air_date), **장르 목록**, **공식 영문 제목**(name/original_name)을 받아온다. 영화라면 `movie/{id}` 엔드포인트로 **개봉연도**와 **장르** 등을 얻는다. 이렇게 얻은 정보를 본 도구에서 표준화된 메타데이터 객체에 채워넣는다.
- **AniDB/MAL 확장 설계**: TMDB 외의 데이터 소스도 플러그인으로 붙일 수 있도록, 공통된 **메타데이터 제공자 인터페이스**를 정의한다. 예를 들어 `MetadataProvider`라는 추상 클래스를 만들고 `search(title) -> metadata` 메소드를 정의하여, TMDB 구현체와 AniDB 구현체가 동일한 메소드를 제공하도록 한다. 추후 AniDB API를 사용하려면, AniDB 클라이언트 모듈이 이 인터페이스를 구현하여 파일 해시 혹은 작품명 기반 검색 기능을 추가할 수 있다. (AniDB의 경우 작품명 검색도 가능하지만 해시 기반이 정확도가 높으므로, 향후 파일 해시 계산 모듈을 연계할 수도 있다.)
- **API 키 관리 및 호출 제한**: TMDB API를 사용하기 위해 필요한 API 키를 안전하게 저장/로드하고, 호출 빈도 제한(rate limiting)을 지킨다. 예를 들어 초당 혹은 분당 호출 제한을 고려하여 요청 사이에 딜레이를 주거나, 다수 파일 처리시 과도한 API 호출을 피하기 위해 캐시와 병행하여 사용한다.
- **작업 목록**:
  - TMDB API 키 및 요청 함수 구현 (Python `requests` 또는 TMDB 전용 파이썬 래퍼 라이브러리 사용).
  - 검색 결과에서 최고 일치 항목 선택 로직 구현 (여러 결과 중 제목 일치도, 연도 비교 등).
  - 세부 정보 가져오기 및 메타데이터 구조화 (예: `{ title: "공식제목", year: 2021, genres: ["Action", "Adventure"], type: "TV" }` 형태).
  - 모듈 단위 테스트: 유명한 작품명을 넣어 올바른 정보를 가져오는지 확인. (예: "Spirited Away" -> year 2001, type Movie, etc.)
  - (확장 대비) `MetadataProvider` 인터페이스 정의와 TMDBProvider 클래스 구현. 이후 AniDBProvider 등을 추가 구현할 수 있도록 클래스 구조 마련.
- **인터페이스 및 의존성**: 이 모듈은 정제된 작품명 등을 입력받아 TMDB (또는 해당 프로바이더) API를 조회하고 메타데이터 객체를 반환한다. 캐시 DB 모듈과 상호작용하여, **검색 전에 캐시 확인** 및 **검색 후 결과 캐싱**을 수행한다. UI/메인 프로세스는 이 모듈을 호출하여 메타데이터를 얻고, 이후 분류 모듈에 전달한다. 네트워크 통신이 수반되므로, Python의 네트워킹 라이브러리에 의존하며, 외부 API의 응답 형식에 종속된다.
- **예외 처리**: 네트워크 오류 또는 TMDB 서비스 불가 상황을 대비한다. 호출 실패 시 일정 횟수 재시도하거나 해당 파일 처리를 건너뛰고 오류를 기록한다. API에서 결과를 찾지 못하면 (예: 제목 불일치) 사용자에게 찾지 못했음을 알리고 해당 파일은 `분류보류` 상태로 둘 수 있다. 또한 예기치 않은 응답 구조 변경에 대비해 응답 파싱 시 KeyError 등에 예외 처리를 넣고, 문제가 발생하면 적절한 오류 로그와 함께 진행을 중단하지 않도록 한다.

### 파일 분류 모듈 (File Classifier)
**역할**: 파일을 메타데이터에 따라 올바른 폴더로 이동시켜 **라이브러리 구조를 형성**하는 기능을 담당한다. 예를 들어 검색된 메타데이터에 따라 {애니메이션}/{name}/{season# or ova or movie}/ 으로 영상과 자막 파일을 모두 이동 시킨다. 이 과정에서 파일명은 변경하지 않고 그대로 유지하며, 영상 파일과 동일한 이름의 자막 파일도 함께 이동시킨다.

**세부 구현**:
- **폴더 경로 생성**: 프로젝트 설정 또는 사용자 입력으로 **정리 기준 템플릿**을 정의한다. 기본값은 "`<연도>/<주요장르>/<작품명>`"으로 한다. 메타데이터로부터 연도(year), 주요 장르(primary genre), 작품명(title)을 가져와 이 템플릿을 채운 경로를 생성한다. 예를 들어 연도 2021, 주요 장르 "Action", 작품명 "Attack on Titan"의 경우 `2021\Action\Attack on Titan\`가 된다. 
  - 주요 장르 선정: 작품에 장르가 여러 개 있을 경우 첫 번째 장르를 사용하거나, 장르 목록 중 대표 장르를 미리 매핑하여 선택한다. (추후 사용자 지정이 가능하도록 옵션화할 수 있다.)
  - 작품명의 특수문자 처리: 파일 시스템 경로에 사용할 수 없는 문자가 포함되어 있다면(예: `:?*"<>|` 등 Windows 예약문자) 이를 제거하거나 대체한다. 또한 작품명이 너무 긴 경우를 대비해 적절한 길이로 자를 수도 있다.
- **디렉토리 생성**: 결정된 경로에 해당 디렉토리가 이미 존재하는지 확인하고, 없다면 재귀적으로 디렉토리를 생성한다 (`os.makedirs` 활용). 이미 존재한다면 건너뛴다. 이 과정에서 동시 처리 시에는 디렉토리 생성의 원자성도 고려해야 하나, 현재는 단일 스레드 처리이므로 큰 문제는 없다.
- **파일 이동**: Python의 `shutil.move` 등을 사용하여 **영상 파일**을 대상 폴더로 이동시킨다. 이동 전에 대상 경로에 **동일한 이름의 파일이 존재하는지 검사**하여, 이미 존재할 경우 이름 충돌 문제가 발생하지 않도록 한다. 충돌 시 "(1)" 등의 접미사를 붙여 이름을 변경하거나, 사용자에게 덮어쓰기 여부를 물어보는 등 정책을 정해야 한다. 기본 동작은 덮어쓰지 않고 새 이름으로 저장하거나, 해당 파일 건너뛰기로 설정한다.
- **자막 파일 연동**: 영상 파일과 같은 디렉토리에 있는 자막 파일(확장자 .srt, .ass 등)을 찾는다. 일반적으로 자막 파일명은 영상 파일명과 거의 동일하고 확장자만 다르므로, 이동 전 원본 폴더에서 `원본파일명.*` 패턴으로 자막을 탐색한다. 발견된 자막 파일이 있다면, **영상 파일을 옮긴 후** 동일한 방식으로 `shutil.move`하여 새로운 폴더로 옮긴다. 이때 자막 파일도 이름 충돌 검사를 수행한다.
- **작업 목록**:
  - 폴더 구조 템플릿 및 기본값 정의 (설정 옵션으로 처리).
  - 메타데이터를 입력받아 폴더 경로를 생성하는 함수 구현.
  - 디렉토리 존재 여부 확인 및 생성 기능 구현.
  - 파일 이동 및 이름 충돌 처리 로직 구현.
  - 자막 파일 탐색 및 이동 기능 구현.
  - 모듈 단위 테스트: 가상의 메타데이터와 임시 파일을 이용하여 의도한 폴더로 이동되는지 확인. (예: temp 디렉토리에서 "Test 2020.mp4" 등을 이동시켜보기)
- **인터페이스 및 의존성**: 이 모듈은 입력으로 **원본 파일 경로**와 해당 파일의 **메타데이터 객체**를 받는다. 모듈 내에서 결정한 대상 폴더 경로로 파일을 옮긴 후, 성공/실패 여부를 호출한 측(UI 또는 메인 프로세스)에 반환하거나 로그로 남긴다. 이 모듈은 운영체제의 파일시스템에 의존하므로 OS 경로 구분자 처리, 권한 문제 등에 영향을 받는다. 다른 모듈과의 의존은 메타데이터 내용에 따라 폴더를 결정하므로 **메타데이터 필드의 존재**에 의존성이 있다. (예: 연도가 없는 경우 "미상연도" 등의 폴더명을 쓸지 결정해야 함)
- **예외 처리**: 파일 이동 중 발생할 수 있는 I/O 예외를 대비한다. 예를 들어, 디스크 용량 부족, 파일 권한 문제, 경로 이름 길이 제한 등의 예외가 발생하면 해당 파일 이동을 실패로 처리하고 에러를 기록한다. 단일 파일 실패가 전체 프로세스를 막지 않도록 try/except로 감싸고, 가능한 한 다음 파일 처리를 이어가도록 한다. 또한 자막 파일이 없어서 발생하는 오류는 없지만, 자막 파일이 읽기 전용이거나 이동 중 문제가 생길 경우에도 처리한다. 파일 시스템상의 예외 외에도, 잘못된 메타데이터로 폴더명을 만들 때 문제가 생길 수 있으므로(예: 폴더명이 너무 김) 그런 경우 폴더명을 줄이는 등 예방 조치를 취한다.

### 캐시 데이터베이스 모듈 (Cache DB)
**역할**: 메타데이터 검색 결과를 저장하여 **중복 검색을 방지**하고 성능을 높이는 캐시 역할을 한다. 동일한 애니메이션 시리즈에 속한 파일을 다수 처리할 경우, 첫 에피소드에서 이미 TMDB ID와 정보를 얻었다면 다음 에피소드는 API를 재조회하지 않고 캐시된 정보를 활용할 수 있다. 또한 한 번 정리한 작품은 기록이 남아 이후 재실행 시에도 불필요한 API 호출을 피할 수 있다.

**세부 구현**:
- **SQLite 선택 이유**: SQLite는 파일 기반의 경량 DB로, 별도 서버 없이 Python 내장 모듈로 사용할 수 있어 본 프로젝트에 적합하다. 배포 시 추가 설치 부담도 없고, 소용량의 캐시 데이터를 저장하기에 충분하다.
- **스키마 설계**: 최소한의 테이블로 간단히 구현한다. 예를 들어 `media_cache`라는 테이블에 `title_key TEXT PRIMARY KEY, year INTEGER, metadata BLOB` 등의 칼럼을 둘 수 있다. `title_key`는 조회 키로 사용할 문자열로, 정제된 작품명과 (필요하다면) 연도를 결합하여 유일성을 갖도록 한다. (단순히 작품명만 쓰면 동명 이작 구별이 어려울 수 있으므로 연도나 타입(영화/TV) 정보를 포함하는 것이 좋다.) `metadata BLOB`에는 메타데이터 객체를 직렬화(예: JSON 문자열)하여 저장한다. 또는 주요 필드(예: TMDB ID, 메인 장르 등)를 별도 칼럼으로 저장할 수도 있다.
테이블은 api_response/search-movie.json과  api_response/search-tv.json을 참조한다.
- **캐시 조회 및 갱신**: API 검색을 수행하기 전에 우선 캐시 테이블에서 `title_key`로 조회를 시도한다. 만약 존재하면, 해당 레코드의 메타데이터를 파싱하여 메타데이터 객체로 복원하고 API 호출을 생략한다. 존재하지 않거나 만료된 경우(향후 확장으로 캐시 만료 개념을 도입할 수 있음) API를 호출한다. API 호출 후 성공적으로 메타데이터를 얻었다면, 이를 캐시 DB에 삽입/갱신한다.
- **동시성 문제**: 기본적으로 단일 스레드/프로세스로 동작하지만, UI 상에서 여러 작업을 병렬로 실행하거나 향후 멀티스레딩 시나리오를 고려하여 DB 접근에 락을 적용할 수 있다. SQLite는 동시 쓰기 시 잠금이 걸리므로, 모듈 내에서 트랜잭션을 짧게 유지하고 필요한 부분에서만 사용하도록 한다.
- **작업 목록**:
  - SQLite DB 파일 생성 및 연결 코드 작성 (앱 최초 실행 시 DB 파일 없으면 생성).
  - 테이블 생성 DDL 실행 (한 번만 수행되도록 보호).
  - 캐시 조회 함수 구현: 입력 키로 SELECT 수행, 결과 없으면 None 반환.
  - 캐시 추가/갱신 함수 구현: 메타데이터 객체를 받아 INSERT or REPLACE 수행.
  - 키 생성 로직 구현: 메타데이터의 작품명과 연도 등을 조합하여 캐시 키 생성.
  - 모듈 단위 테스트: 임의의 키로 삽입 후 조회 테스트, 없는 키 조회 테스트 등.
- **인터페이스 및 의존성**: 이 모듈은 주로 **메타데이터 검색 모듈**에 의해 사용된다. 검색 모듈이 캐시를 조회/쓰기 위해 이 모듈의 함수를 호출하는 식이다. UI나 다른 부분에서는 직접 캐시 DB에 접근할 필요는 없지만, 필요시 캐시를 초기화하거나 내용 확인용으로 접근하는 기능(예: 개발자 디버그용)을 둘 수 있다. 의존성으로는 Python의 `sqlite3` 표준 라이브러리를 사용하며, 메타데이터 객체의 직렬화에 JSON 모듈 등을 사용한다.
- **예외 처리**: DB 파일이 손상되었거나 테이블 구조가 예상과 다를 경우 예외가 발생할 수 있다. 이런 경우 캐시를 새로 만드는 쪽으로 유도한다. 실행 중 DB Lock 예외가 발생하면 일정 시간 대기 후 재시도하거나, 캐시 사용을 건너뛰도록 한다. 캐시 실패는 치명적이지는 않으므로, 캐시를 아예 사용하지 않고 계속 진행할 수 있게 설계한다. (예: 캐시 읽기 실패 시 그냥 API를 호출하고, 쓰기 실패 시 로그만 남김.)

### 사용자 인터페이스 모듈 (PyQt5 UI)
**역할**: 위의 모든 기능을 사용자가 쉽게 활용할 수 있도록 **그래픽 사용자 인터페이스**를 제공한다. 단일 창 형태의 PyQt5 애플리케이션으로 구현되며, 파일 선택부터 정리 작업의 진행 상황, 결과 확인까지의 전 과정을 UI 상에서 제어한다. UI 모듈은 내부적으로 다른 모듈들을 호출하여 작업을 수행하며, 사용자에게는 진행 상황 로그 또는 상태를 보여준다.

**세부 구현**:
- **UI 주요 컴포넌트**:  
  - **파일/폴더 선택 영역**: 사용자가 탐색기 대화창 등을 통해 정리할 개별 파일이나 전체 폴더를 선택할 수 있는 입력 필드를 제공한다. (예: "폴더 열기" 버튼을 눌러 다운로드 폴더를 선택) 선택된 경로는 리스트 형태로 내부 관리한다.  
  - **옵션 설정 영역**: 기본 폴더 구조 템플릿(`연도/장르/작품명`) 이외에 사용자가 원하는 분류 기준이 있다면 이를 입력하거나 선택할 수 있는 옵션 UI를 둔다. 또한 사용할 메타데이터 소스(TMDB/AniDB 등)를 선택하는 드롭다운, 캐시 재사용 여부, 미분류 파일 처리 옵션 등의 고급 설정도 고려한다. (초기 버전에서는 기본값으로 숨겨두고, 추후 "설정" 다이얼로그로 제공)  
  - **진행 상황 표시**: 작업 시작 후 처리되는 각 파일에 대한 상태를 실시간으로 보여주는 영역이 필요하다. 예를 들어 다중 라인 텍스트 박스나 로그 창 형태로 "파일 X -> 검색 완료 -> 이동 완료" 등의 메시지를 출력한다. 경우에 따라 진행률 프로그레스바를 표시하여 전체 몇 % 완료됐는지도 보여줄 수 있다.  
  - **실행 및 제어 버튼**: "정리 시작" 버튼을 누르면 선택된 파일들에 대한 정리가 시작된다. 정리 중에는 버튼이 "정지" 또는 "취소"로 변경되어 사용자가 긴급 중단할 수 있게 한다. 중단 시 이미 진행 중인 파일 처리는 완료하고 대기 중인 파일 처리는 건너뛴다.  
- **비동기 처리**: UI의 응답성을 유지하기 위해 **별도 스레드** 또는 Qt의 `QRunnable`/`QThreadPool` 등을 사용하여 파일 정리 작업을 백그라운드에서 실행한다. 메인 UI 스레드는 작업 스레드와 **시그널/슬롯** 메커니즘으로 통신하며, 작업 진행 상황을 수신하여 UI 요소를 갱신한다. 이를 통해 많은 파일 처리 중에도 UI가 멈추지 않고, 사용자는 진행 로그를 실시간 확인할 수 있다.
- **예외 및 오류 표시**: 작업 중 발생한 오류(예: 네트워크 실패, 파일 이동 실패 등)는 UI에 명확히 표시되어야 한다. 예를 들어 특정 파일 옆에 "메타데이터 찾기 실패"와 같은 표시를 남기거나, 전체 완료 후 팝업 다이얼로그로 "3개 파일은 분류하지 못했습니다"를 알릴 수 있다. 심각한 예외로 작업이 중단될 경우 해당 예외 메시지를 로그에 남기고 사용자에게 안내하여 버그 신고나 후속 조치를 취할 수 있게 한다.
- **작업 목록**:
  - PyQt5 UI 레이아웃 디자인 (가능한 간단하고 단일 창으로).
  - 파일/폴더 선택 기능 구현 (`QFileDialog` 활용).
  - "시작" 버튼 클릭 시 별도 작업 스레드 시작 및 모듈 연동 호출.
  - 작업 진행을 위한 워커(Worker) 클래스 구현: 이 클래스 내에서 앞서 정의된 클리너 -> API -> 캐시 -> 분류기 과정을 순차 수행하고, 각 단계마다 시그널을 emit하여 UI를 업데이트.
  - 진행 로그/결과 표시 위젯 구현 및 시그널 연결.
  - 작업 취소 기능 구현 (작업 스레드 내 플래그를 두어 루프 중단).
  - UI 모듈 테스트: 실제 파일 몇 개를 선택하여 동작시키는 수작업 테스트 및 예외 상황(네트워크 끊기 등)에서 UI 응답 확인.
- **인터페이스 및 의존성**: UI 모듈은 모든 다른 모듈을 **컨트롤러**처럼 사용한다. 파일명 클리너, API 클라이언트, 파일 분류기, 캐시 DB 모듈을 모두 가져와 사용하며, 이들 모듈 간의 호출 흐름을 관리한다. 의존성 측면에서 UI는 이러한 내부 모듈의 인터페이스에 의존하며, 각 모듈의 함수/메소드가 약속된 대로 동작해야 한다. 반대로 다른 모듈은 UI를 모르기 때문에, UI와 모듈 간에는 느슨한 결합을 유지한다.
- **예외 처리**: UI 레벨에서는 어떤 모듈에서 오류가 발생하더라도 **애플리케이션 크래시로 이어지지 않도록** 최후의 보루 역할을 한다. 모든 작업 쓰레드의 예외를 잡아서 UI에 전달하며, 미처 잡지 못한 예외가 메인 스레드로 올라와도 `sys.excepthook` 등을 활용해 오류를 띄우고 앱이 안정적으로 종료되도록 한다. 또한 종료 시 작업 쓰레드를 제대로 종료(join)하여 리소스 누수를 방지한다.

### 플러그인 아키텍처 (Plugin Architecture)
**역할**: 시스템의 **확장성**을 높이기 위해 일부 기능을 플러그인으로 추가/교체할 수 있는 구조를 마련한다. 상위 TMDB API 역시 플러그인 형식으로 코딩한다. 이를 통해 개발자는 초기 요구사항 외에 향후 새로운 API 지원, 새로운 분류 방식, 추가 UI 기능 등을 독립적인 모듈로 개발하여 프로그램에 통합할 수 있다. 플러그인 아키텍처는 코드 수정 없이 기능 확장을 가능케 하여, 오픈소스로 발전할 경우 외부 기여도 수용할 수 있는 유연한 기반이 된다.

**세부 구현**:
- **메타데이터 소스 플러그인**: 앞서 설계한 `MetadataProvider` 인터페이스에 따라 플러그인 디렉토리에 배치된 모듈을 동적으로 로드하는 방식이다. 예를 들어 `plugins/metadata/` 폴더 아래에 `anidb_provider.py`가 존재하면, 애플리케이션 시작 시 해당 모듈을 임포트하여 `MetadataProvider`를 상속한 클래스 객체를 가져온다. UI 상에서는 사용 가능한 메타데이터 소스 목록에 "AniDB"가 자동 추가되며, 사용자가 선택하면 TMDB 대신 해당 플러그인을 사용하여 검색하게 한다. 이와 같이 새로운 소스 추가 시 코어 코드를 수정하지 않고 파일 추가만으로 인식되도록 구현한다.
- **분류 규칙 플러그인**: 폴더 구조 결정 로직을 커스터마이즈하기 위해 `ClassifierPlugin` (또는 분류 규칙 인터페이스)을 정의한다. 기본 분류기능은 연도/장르/제목으로 하되, 예를 들어 일부 사용자는 **제목/시즌** 구조나 **장르 무시** 등 다른 정리 규칙을 선호할 수 있다. 플러그인 폴더 내에 새로운 분류 클래스 (예: `SeasonFolderClassifier`)를 정의하면, 설정에서 해당 규칙을 선택해 적용할 수 있도록 한다. 분류 플러그인은 메타데이터 객체를 받아 경로 문자열을 반환하는 동일한 인터페이스를 지키도록 규약한다.
- **UI 확장 플러그인**: PyQt5 UI에 동적으로 새로운 탭이나 메뉴를 추가하는 것은 복잡하지만, 사전에 Hook 지점을 만들어둘 수 있다. 예를 들어, `plugins/ui/` 폴더에서 발견된 플러그인 모듈들은 `QWidget`을 상속한 클래스(예: 설정 패널, 통계 패널 등)를 제공할 수 있고, 프로그램 실행 시 메인 탭 위젯에 추가되도록 만든다. 이를 통해 기본 제공하지 않는 부가 기능 (예: 캐시 DB 편집기, 또는 파일명 패턴 테스트 도구 등)을 필요에 따라 플러그인으로 개발하여 붙일 수 있다. UI 플러그인은 충돌을 방지하기 위해 독립적인 탭으로만 추가하고, 코어 기능을 대체하지는 못하도록 한다.
- **플러그인 로딩 관리**: 플러그인을 관리하는 매니저를 구현한다. 애플리케이션 시작 시 특정 디렉토리 경로를 탐색하여 `.py` 파일들을 모으고, 각각 임포트한 뒤 사전에 정의된 객체나 함수를 검색한다. (예: `register_plugin()` 함수를 각 플러그인 모듈이 구현하게 하여, 호출 시 해당 플러그인이 등록할 클래스나 정보를 반환하도록 규약) 이렇게 수집된 플러그인 목록을 코어 모듈이나 UI에 전달하여 최종 동작에 반영한다. 플러그인에서 문제가 발생할 경우(예: ImportError) 해당 플러그인을 건너뛰고 계속 로드하며, 오류 내용은 로그에 기록한다.
- **작업 목록**:
  - 플러그인 디렉토리 구조 및 로딩 메커니즘 구현.
  - `MetadataProvider` 및 `ClassifierPlugin` 추상 베이스 클래스 정의.
  - 샘플 TMDBProvider, 기본 Classifier를 플러그인 형태로 분리 (코어 내장도 가능하지만, 예시로 분리해봄).
  - 플러그인 선택/설정 UI 요소 구현 (예: 메타데이터 소스 선택 드롭다운, 분류 규칙 선택 옵션).
  - 플러그인 로딩 오류 처리 및 로그 구현.
  - 테스트: 의도적으로 간단한 플러그인 만들어 로딩 검증, 잘못된 플러그인으로 오류 발생 시도 등.
- **인터페이스 및 의존성**: 플러그인은 코어 시스템이 정의한 인터페이스를 구현해야 하며, 코어는 플러그인에 대해 알고 있지만 반대로 플러그인은 코어 내부 구현에 직접 접근하지 않는 방향으로 한다. (필요하다면 콜백이나 코어 객체의 참조를 전달할 수 있으나, 설계를 복잡하게 하지 않도록 최소한으로 제한) 의존성 측면에서, 코어 시스템은 파일시스템(특정 폴더 경로)에 플러그인이 존재한다는 가정하에 동작하며, 플러그인이 없다면 기본 내장 기능만으로 동작 가능해야 한다. 
- **예외 처리**: 플러그인 로딩 중 발생하는 예외, 플러그인 실행 중 발생하는 예외 모두 개별적으로 포착하여 코어에서 처리한다. 예를 들어 특정 플러그인의 `search()` 메소드에서 예외가 던져지면 코어는 해당 플러그인 호출을 중단하고 다른 소스로 대체하거나, 사용자에게 해당 소스에 문제가 있음을 알린다. 플러그인으로 인해 전체 시스템이 중단되는 일이 없도록 각 플러그인 경계를 넘어오는 예외는 모두 잡아서 무시하거나 로그한다.

## 모듈 간 인터페이스 및 의존성
각 모듈은 위와 같이 개별적으로 설계되었으며, 전체 시스템 내에서는 **아래 그림과 같은 흐름으로 상호작용**한다:

1. **UI 모듈**은 사용자 입력을 받아 파일 경로 목록을 확보한다. 그런 다음 각 파일 경로를 **파일명 클리너 모듈**에 전달한다.  
2. **파일명 클리너 모듈**은 파일명 문자열을 분석하여 정제된 작품명을 추출하고, 이를 UI/메인 프로세스에 반환한다. UI 모듈은 이 결과를 **캐시 DB 모듈**과 **API 모듈**에 넘겨준다. (UI가 직접 캐시를 조회할 수도 있고, API 모듈 내부에서 캐시를 확인하도록 구현할 수도 있다. 설계상 둘 다 가능하나, API 모듈 내부에서 캐시를 다루는 것이 응집도가 높다.)  
3. **메타데이터 검색 모듈**은 입력받은 작품명으로 우선 **캐시 DB 모듈**을 조회한다. 캐시에 해당 작품 메타데이터가 있다면 곧바로 결과를 반환하고, 없으면 TMDB API 호출을 수행한다. API로 얻은 메타데이터는 **캐시 DB**에 저장하고 UI 모듈로 반환한다.  
4. UI 모듈은 받은 메타데이터를 **파일 분류 모듈**에 전달하면서, 원본 파일 경로와 함께 호출한다.  
5. **파일 분류 모듈**은 메타데이터를 사용하여 폴더 경로를 결정하고 파일 이동을 수행한다. 이동이 완료되면 UI 모듈에 완료 또는 실패 결과(예: boolean 혹은 예외) 신호를 보낸다.  
6. UI 모듈은 해당 파일의 처리가 끝났음을 로그에 기록하고, 다음 파일로 반복한다. 모든 파일에 대해 이 과정을 거친다.

위 과정에서 **모듈 간의 의존성**을 정리하면 다음과 같다:

- **UI ↔ 파일명 클리너**: UI는 클리너를 호출하여 결과 문자열을 받는다. 클리너는 UI에 의존하지 않고 동작하며, UI와 1:1로만 데이터 교환(파일명 in -> 정제명 out)을 한다.
- **UI/검색모듈 ↔ 캐시 DB**: 검색 모듈이 캐시 DB를 직접 활용하는 경우, UI는 캐시 DB를 의식하지 않아도 된다. 검색 모듈은 캐시 DB 모듈의 함수를 호출하며, 반대로 캐시 DB 모듈은 검색 모듈에 의존하지 않는다. (둘 사이는 DB API로 연결)
- **UI ↔ 메타데이터 검색 모듈**: UI는 검색 모듈에 질의하고 메타데이터를 얻는다. UI는 어떤 프로바이더(TMDB 등)를 사용하는지 몰라도 되며, 검색 모듈 내부 구현에만 의존한다. 둘 간에는 `search(title) -> metadata` 같은 인터페이스로 연결된다.
- **UI ↔ 파일 분류 모듈**: UI는 원본 파일 경로와 메타데이터를 분류 모듈에 전달하여 폴더 생성/이동을 수행시킨다. 분류 모듈은 파일 시스템에 의존하며, UI는 결과(성공/실패)를 받는다. 
- **플러그인 매니저**: UI 또는 코어 프로세스는 시작 시 플러그인 매니저를 통해 메타데이터 검색 모듈이나 분류 모듈 등을 대체/확장할 플러그인을 로드한다. 이때 UI/코어는 플러그인의 존재에만 의존하며, 없으면 기본 구현을 사용한다. 각 플러그인은 정해진 인터페이스를 구현하여 코어와 통신하므로, 플러그인 자체는 다른 모듈 구현에 강한 결합을 갖지 않는다.
- **외부 의존성**: 메타데이터 모듈은 TMDB 등 **외부 API 서비스**에 의존한다. 이는 시스템 외부 의존성이므로, 응답 지연이나 실패 가능성을 항상 고려해야 한다. 파일 분류 모듈은 **운영체제 파일시스템**에 의존하며, 이 또한 외부 환경 요인(디스크 상태 등)에 영향을 받는다. 이러한 외부 의존성 부분에서 예외 상황이 주로 발생할 수 있다.

전체적으로 모듈 간 인터페이스는 함수 호출과 데이터 전달로 비교적 단순하게 구성하며, **데이터 흐름의 방향**은 UI/메인 → 클리너 → 검색/캐시 → 분류 → UI 로 일방향 흐름을 가진다 (검색 모듈 ↔ 캐시 DB 간은 양방향 조회/갱신). 이러한 구조는 각 컴포넌트를 개별 개발 및 테스트하기 용이하게 해주며, 특정 모듈 변경이 다른 모듈에 최소한의 영향만 미치도록 한다.

## 예외 처리 방안
안정적인 파일 정리를 위해서는 다양한 오류 상황에 대한 대비가 필요하다. 각 모듈과 전체 프로세스 수준에서 고려해야 할 예외 상황과 처리 방안을 정리하면 다음과 같다:

- **네트워크 오류 및 API 예외**: 메타데이터 조회 시 인터넷 연결 불안정, TMDB API 장애, 호출 제한 초과 등의 이슈가 발생할 수 있다. 이를 위해 검색 모듈에서는 API 호출 실패 시 **재시도 로직**을 2~3회 정도 수행하고, 그래도 실패하면 해당 파일에 대해서는 "메타데이터 검색 실패"로 표시한 뒤 다음 파일로 넘어간다. 또한 HTTP 응답 코드가 401(인증 실패)인 경우 잘못된 API 키 또는 키 만료로 볼 수 있으므로, 즉시 작업을 중단하고 UI에 에러를 알려 사용자가 API 키 설정을 확인하도록 한다.
- **API 결과 없음**: API 호출은 성공했으나 해당 작품명을 찾지 못하는 경우가 있다. 이런 경우 검색 모듈은 None을 반환하거나 Exception을 던질 수 있는데, UI에서는 이를 받아 **해당 파일을 건드리지 않고** 건너뛴다. 최종 완료 후 "다음 파일들은 인식되지 않아 분류하지 못했습니다: [파일명 목록]..." 식으로 사용자에게 알려 수동 처리하도록 유도한다. 향후 개선으로, 이러한 경우 사용자가 수동으로 작품명을 입력하거나 검색 결과 목록 중 선택할 수 있게 할 계획이지만, 1차 버전에서는 자동 건너뛰기만 구현한다.
- **메타데이터 불완전**: 간혹 API 결과에 필요한 필드(예: 장르)가 비어있거나 비정상적일 수 있다. 예를 들어 신작의 경우 TMDB에 장르 정보가 아직 없을 수도 있다. 분류 모듈은 이런 상황에서 기본 폴더 구조의 해당 필드를 "기타" 또는 "Unknown" 등의 값으로 대체하여 경로를 생성한다. (예: 장르 없음 -> "기타" 폴더에 분류) 또한 연도 정보가 없으면 "0000" 등으로 표시할 수 있다. 이렇게 함으로써 메타데이터의 부분적 결함이 있어도 프로세스를 진행 가능하도록 한다.
- **파일 I/O 오류**: 파일 이동이나 디렉토리 생성 중 발생하는 오류에 대비한다. 대표적으로 대상 디스크 공간 부족, 이동 권한 부족, 경로 이름이 너무 긴 경우, 동일한 파일 존재 등이 있다. 
  - 디스크 공간/권한 문제: 이 경우 Python `shutil`에서 예외를 던지므로, catch하여 UI에 "경로 접근 불가" 등의 메시지를 전달한다. 사용자가 경로를 변경하거나 디스크 상태를 확인하도록 안내하고, 해당 파일은 미처리 상태로 남긴다.
  - 파일 이름 충돌: 대상 폴더에 이미 같은 이름의 파일이 있을 경우, 기본 설정은 **덮어쓰지 않고** 새 이름으로 저장하거나 건너뛰도록 한다. 만약 새 이름으로 저장하는 경우 "파일명 (1).ext" 형식으로 바꿔 저장하고, 이 사실을 로그에 기록한다. 건너뛰는 정책이라면 해당 파일을 분류 실패 목록에 넣고 사용자에게 알린다. 사용자 설정으로 덮어쓰기 허용 옵션을 둘 수도 있다.
  - 경로명 오류: Windows 경로 길이 제약(MAX_PATH) 등으로 실패하면, 대상 폴더명을 줄이는 등의 대비가 필요하다. 자동으로 폴더명을 약어로 바꾸거나 하는 것은 어렵기에, 일단 실패 시 사용자에게 폴더 구조를 단순화하도록 권고하는 메시지를 제공한다.
- **자막 파일 관련**: 자막 파일이 없으면 반드시 오류는 아니지만, 혹시 영상과 자막 이름이 일치하지 않아 누락되는 경우가 있을 수 있다. 이를 위해 파일 이동 전 원본 폴더에서 **동일 prefix를 가진 모든 파일**을 검색하여 영상 외 부가 파일(자막, 챕터 등)을 찾는 방법도 고려한다. 1차 버전에서는 같은 이름의 자막만 처리하지만, 사용자에게 "자막 파일을 발견하지 못했습니다"를 알려주어 추가 확인하도록 할 수 있다. 자막 이동 중 실패(앞서 언급한 I/O 문제와 동일 원인) 시도 개별 처리한다.
- **UI 예외**: 예를 들어, 사용자가 정리 작업 중 프로그램을 강제 종료하거나, UI 버튼을 연타하는 등 예외적인 사용 패턴도 고려한다. "정지" 기능을 구현하여 안전하게 중단하는 방법을 제공하되, 강제 종료 시에도 현재까지 완료된 작업은 유지되도록 트랜잭션 성 처리를 한다. (예: 진행 중이던 파일 이동이 완전히 끝나기 전에 종료하면 파일이 반쯤 옮겨져 있는 상황이 생길 수 있으므로, 가능하다면 종료 시점을 제어하거나, 다음 실행 시 비정상 종료 로그를 보고 복구하는 방안 등도 생각해볼 수 있다.)
- **전역 예외 처리**: 예측하지 못한 버그로 인한 예외가 발생할 경우를 대비해, 메인 루프에 **전역 예외 핸들러**를 건다. 이를 통해 치명적인 오류 발생 시에도 로그를 남기고 프로그램이 완전히 죽지 않거나, 적어도 오류 메시지를 사용자에게 보여주고 종료되도록 한다. 개발 중에는 콘솔에 traceback을 출력하고, 배포 버전에서는 사용자 친화적 안내와 함께 로그 파일 저장을 병행한다.

각 모듈 구현 시 위 예외 상황별 대응 코드를 포함하고, **통합 테스트** 단계에서 이러한 오류 상황을 시뮬레이션하여 제대로 처리되는지 확인한다. 이를 통해 예상되는 오류는 최대한 사용자에게 큰 문제 없이 넘어갈 수 있게 하고, 예상치 못한 오류는 로그/보고를 통해 개선해나가는 전략을 취한다.

## 통합 테스트 계획
모듈별 단위 테스트를 통해 개별 기능의 정확성을 검증한 후, 전체 시스템이 요구사항대로 동작하는지 확인하기 위한 통합 테스트를 실시한다. 통합 테스트는 다양한 시나리오의 입력 파일을 실제로 처리해보고 결과를 확인하는 방식으로 이루어진다. 주요 테스트 시나리오는 다음과 같다:

1. **정상 동작 시나리오**: 여러 형태의 파일명을 가진 애니메이션 파일 5~10개와 그 중 일부의 자막 파일을 준비한다. 예를 들어:  
   - `[Leopard-Raws] Attack on Titan S4 01 [1080p].mkv` (시리즈 에피소드 파일)  
   - `My Hero Academia - Two Heroes (2018) [BDRip 1080p].mkv` (극장판 영화 파일)  
   - `One Piece 1000.mp4` (네이밍이 단순한 파일) 등.  
   이러한 파일들을 테스트 폴더에 넣고 프로그램을 실행하여 분류 결과를 확인한다. 기대 결과:
   - 해당 작품별로 올바른 폴더가 생성되고, 그 안에 파일이 존재하는지 (예: `2020\Action\Attack on Titan\Attack on Titan S4 01 [1080p].mkv` 형태로 이동 되었는지).
   - 자막 파일이 있었다면 영상과 함께 옮겨졌는지 (`Attack on Titan S4 01 [1080p].ass`가 동일 폴더에 존재하는지).
   - UI 로그에 각 단계가 제대로 출력되고 오류 없이 완료되었는지.
2. **API 미일치 시나리오**: 일부러 존재하지 않는 제목의 파일 또는 잘못된 철자의 파일명을 포함시킨다 (예: `Naruto Shippuden 9999.mkv` 같은 실제 존재하지 않는 에피소드). 실행 후 해당 파일이 **분류 보류**로 처리되고, 다른 정상 파일들은 영향받지 않고 이동되는지 확인한다. 또한 UI에 해당 파일이 검색 실패로 표시되는지 본다.
3. **오류 시나리오**: 
   - 네트워크 연결을 끊은 상태에서 실행하여 TMDB 조회 단계에서 실패를 유도한다. 이때 재시도 동작 여부와 최종적으로 오류 처리가 되는지 확인한다. 네트워크 재연결 후 재실행 시 정상 처리되는지도 검증한다.
   - 대상 디렉토리를 읽기전용으로 만들어 파일 이동이 실패하는 상황을 만든다. 분류 모듈에서 예외를 처리하여 UI 로그에 오류를 남기고, 프로그램이 중단되지 않으며 나머지 파일 처리를 시도하는지 확인한다.
   - 캐시 DB 파일을 잠그거나(Read-Only) 오류를 발생시켜 캐시 모듈 예외 처리를 확인한다. 캐시 장애 시에도 API 직접 조회로 폴백하여 전체 작업은 완료되어야 한다.
4. **동시 처리/취소 시나리오**: (해당 기능 구현 시) 정리 작업 도중 "취소" 버튼을 눌러 중단시킨다. 이미 진행된 파일들은 옮겨졌지만, 남은 파일들은 그대로 남아있는지 확인한다. 다시 작업을 재개하면 중단된 부분부터 처리 가능하거나, 이미 옮겨진 파일은 건너뛰는 로직이 있는지 본다.
5. **경계 케이스 시나리오**: 
   - 파일명이 극도로 긴 경우나 특수문자가 많은 경우 처리 확인.
   - 한 폴더에 에피소드 수백 개를 한번에 처리해 성능 확인 (대용량 테스트).
   - 동일한 작품의 에피소드들이 섞여 있는 경우 캐시 활용으로 API 호출이 한 번만 일어나는지 로그를 통해 검증.

**테스트 절차**: 위 시나리오를 수동으로 실행하면서, 결과 폴더 구조와 UI 로그, 그리고 내부 로그 파일(DB 내용 등)을 확인한다. 발견된 버그나 예상과 다른 동작은 원인을 분석하여 수정한 후 재테스트한다. 특히 **모듈 간 연계**에서 정보 손실이나 오동작이 없는지 집중 검증한다. 예를 들어 파일명 클리너 결과가 잘못되어 엉뚱한 작품으로 분류되지 않았는지, 여러 파일이 동일 작품으로 인식될 때 캐시가 제대로 작동했는지 등을 본다.

**자동화 가능성**: 가능하다면 PyQt5 UI를 통하지 않고, 내부 로직을 호출하는 방식으로 통합 테스트를 자동화할 수도 있다. 예를 들어, UI 모듈의 작업 수행 함수를 직접 호출하여 파일 리스트를 입력하고, 최종 결과를 확인하는 테스트 코드를 작성한다. 이를 통해 지속적인 리그레션 테스트가 가능하다. 다만 PyQt5 GUI 이벤트 루프를 동반하므로 완전한 자동화는 어렵고, 핵심 로직을 UI 밖으로 분리하여 테스트하는 정도로 계획한다.

**테스트 환경**: Windows 11 개발 PC에서 주로 테스트하며, 나아가 배포를 고려하여 다른 Windows PC 및 (가능하면) Linux Wine 환경 등에서도 시범 실행해본다. Python 3.12 환경에서 정상 동작을 확인하고, 패키징 한 exe가 테스트 머신에서 의존성 문제없이 실행되는지도 검토한다.

## 향후 개선 및 확장 계획
초기 버전 출시 후 사용자 피드백과 기술 발전에 따라 개선할 기능과 확장 아이디어는 다음과 같다:

- **메타데이터 소스 확장**: 현재 TMDB에 의존하는 메타데이터 검색을 **AniDB**나 **MyAnimeList** API로 확장한다. AniDB의 경우 방대한 애니메이션 데이터베이스를 가지고 있고, 특히 파일 해시를 이용한 검색으로 정확도를 높일 수 있다. MyAnimeList API도 작품 정보와 유저 평점 등을 얻는 데 활용 가능하다. 이러한 소스 추가는 플러그인 구조를 통해 자연스럽게 이루어질 예정이며, 사용자는 설정에서 원하는 정보 소스를 선택하거나, **다중 소스 병합**을 통해 더 풍부한 메타데이터(예: TMDB에서 장르, AniDB에서 방송 형식 정보를 조합)를 활용할 수 있게 된다.
- **파일명 파싱 고도화**: 정규표현식으로 처리하기 애매한 사례들을 다루기 위해 **머신러닝 기반 파싱**을 도입한다. 방대한 애니메이션 릴리즈 파일명 데이터를 학습한 ML 모델을 개발하거나, 오픈소스 **네이밍 파서**가 있다면 활용해본다. 이를 통해 현재 규칙 기반으로 누락되는 케이스(팬덤에서만 통용되는 약어 제목 등)를 인지하고 정확히 작품명을 추출할 수 있다. ML 적용 시에도 결과를 검증하는 로직을 두어, 확신도 낮은 결과는 기존 방식과 대조하거나 사용자에게 확인을 요청하는 등 보완 장치를 둘 계획이다.
- **사용자 개입 및 확인 옵션**: 완전 자동으로 진행하되, 사용자의 선택에 따라 **반자동 모드**도 지원한다. 예를 들어, 검색 결과가 여러 개인 모호한 경우 UI에 후보 목록을 보여주고 사용자가 올바른 항목을 선택하도록 하는 인터랙티브한 흐름을 추가한다. 또는 실제 파일 이동 전에 **미리보기 목록**을 제공하여 "다음과 같이 폴더를 생성하고 파일을 옮길 예정입니다"를 보여준 뒤 사용자가 확인/취소할 수 있게 하는 단계도 고려한다. 이를 통해 잘못된 분류를 사전에 방지하고 사용자 신뢰도를 높일 수 있다.
- **폴더 구조 커스터마이즈**: 현재 고정된 연도/장르/제목 구조를 사용자 임의로 변경할 수 있도록 **템플릿 설정 기능**을 추가한다. 예를 들어 사용자에 따라 "장르별 분류가 불필요하니 연도/제목으로만 폴더를 구성하고 싶다"거나, "시즌별 폴더를 포함하고 싶다(제목/시즌/)" 등의 요구가 있을 수 있다. 이를 위해 UI에서 폴더 구조를 정의할 수 있는 간단한 DSL이나 텍스트 포맷을 제공하거나, 몇 가지 프리셋을 마련한다. (예: 기본, Plex 표준, 장르 없음, 시즌별 등) 이때 **FileBot**과 같이 강력하고 유연한 이름/폴더 패턴 커스터마이즈 기능도 참고할 수 있다 ([FileBot - The ultimate TV and Movie Renamer](https://www.filebot.net/#:~:text=FileBot%20makes%20renaming%20and%20organizing,the%20%207%20naming%20standard)) ([FileBot - The ultimate TV and Movie Renamer](https://www.filebot.net/#:~:text=Rename%20and%20move%20hundreds%20of,and%20highly%20customizable%20naming%20scheme)). FileBot은 온라인 DB 정보에 기반해 수백 개의 미디어 파일을 자동으로 이름 변경 및 재정렬할 수 있고, 사용자가 직접 **네이밍 스킴**을 설정하여 Plex나 Kodi와 호환되는 구조로 조직화할 수 있는 도구이다 ([FileBot - The ultimate TV and Movie Renamer](https://www.filebot.net/#:~:text=FileBot%20makes%20renaming%20and%20organizing,the%20%207%20naming%20standard)) ([FileBot - The ultimate TV and Movie Renamer](https://www.filebot.net/#:~:text=Rename%20and%20move%20hundreds%20of,and%20highly%20customizable%20naming%20scheme)). 이러한 기능을 벤치마킹하여 우리 프로그램에도 적용하면 전문 사용자들의 세부 요구도 충족시킬 수 있을 것이다.
- **자막 및 부가 기능 확장**: FileBot이 제공하는 기능처럼 온라인 자막을 자동으로 다운로드해주는 기능이나 ([FileBot - The ultimate TV and Movie Renamer](https://www.filebot.net/#:~:text=3)), 커버 이미지(포스터)를 함께 저장하는 기능도 향후 고려한다. 예를 들어, OpenSubtitles API를 연동하여 정리된 폴더 내에 해당 영상의 자막이 없는 경우 자동으로 자막을 받아 저장하거나, TMDB로부터 썸네일 이미지를 받아 폴더 내 JPG로 저장해주는 식이다. 이러한 부가기능은 애니메이션 아카이브를 더욱 풍성하게 만들어주며, **완전한 미디어 관리 솔루션**으로 발전시킬 수 있다.
- **해시 기반 파일 매칭**: Shoko 등에서 활용하는 **파일 해시 매칭 기법** ([Shoko | Anime Management System](https://shokoanime.com/#:~:text=Shoko%20streamlines%20your%20anime%20collection,your%20next%20anime%20to%20watch)) ([Shoko | Anime Management System](https://shokoanime.com/#:~:text=Shoko%20provides%20robust%20tools%20for,TMDB%20links%20per%20series%2C%20Shoko))도 장기적으로 도입 검토한다. 파일명을 통한 검색은 한계가 있으므로, 파일 내용을 해시하여 AniDB의 해시 DB와照합하면 100% 정확도로 어떤 작품의 몇 화인지 식별할 수 있다. Shoko는 이를 통해 자동으로 파일명을 변경/이동하고 메타데이터까지 채워주는 고급 기능을 제공하고 있는데 ([Shoko | Anime Management System](https://shokoanime.com/#:~:text=Shoko%20provides%20robust%20tools%20for,TMDB%20links%20per%20series%2C%20Shoko)), 우리 도구에도 해시 계산 및 AniDB ID 조회 기능을 추가하면 애니메이션 정리의 신뢰도를 크게 높일 수 있다. 다만 해시 조회는 시간이 오래 걸릴 수 있어, 희망 사용자에 한해 옵션으로 제공하거나 배치 처리로 실행하는 방안을 고려한다.
- **성능 및 대용량 처리 최적화**: 파일 수가 매우 많은 경우 (예: 수천 개의 애니메이션 에피소드) 현재 구조는 순차 처리이므로 시간이 오래 걸 수 있다. 이를 개선하기 위해 멀티스레딩 또는 비동기 I/O를 도입하는 방안을 생각해본다. 예를 들어, 네트워크 대기시간 동안 다른 파일의 정제를 병렬로 처리하거나, 서로 다른 API 호출을 병렬 수행하는 것이 가능하다. 그러나 너무 많은 동시 호출은 API 제한에 걸릴 수 있으므로, **스레드 풀**을 활용하여 적정 수준의 동시성으로 성능과 안전성의 균형을 잡는다. 또한 데이터베이스 액세스도 빈번하지 않게 알고리즘을 최적화한다(동일 시리즈 묶어서 처리 등).
- **크로스플랫폼 및 배포**: Windows용 exe 패키징 이외에 macOS, Linux 사용자도 사용할 수 있도록 배포 범위를 넓힐 수 있다. PyQt5 기반이므로 UI 코드는 큰 수정 없이 동작할 가능성이 크다. macOS의 `.app` 번들, Linux의 AppImage 등을 생성하는 방법을 연구하여 제공하면 커뮤니티를 확대할 수 있다. 또한 설치가 필요 없는 포터블 버전, 자동 업데이트 기능 등의 배포 편의성도 추후 고려한다.
- **유사 도구 벤치마킹**: 앞서 언급한 FileBot, Shoko 등의 유사 도구들의 장점을 적극 참고한다. FileBot은 다양한 DB를 활용한 미디어 파일 정리의 표준격인 도구로서, **일괄 파일 이동 및 이름 변경**, **사용자 정의 스크립팅**, **서브타이틀 다운로드** 등의 풍부한 기능을 갖추고 있다 ([FileBot - The ultimate TV and Movie Renamer](https://www.filebot.net/#:~:text=FileBot%20is%20the%20ultimate%20tool,It%27s%20smart%20and%20just%20works)) ([FileBot - The ultimate TV and Movie Renamer](https://www.filebot.net/#:~:text=Rename%20and%20move%20hundreds%20of,and%20highly%20customizable%20naming%20scheme)). Shoko는 애니메이션에 특화되어 **해시 기반 식별**과 **컬렉션 관리**, **다양한 플레이어와의 연동**을 지원하는 고급 시스템이다 ([Shoko | Anime Management System](https://shokoanime.com/#:~:text=Shoko%20streamlines%20your%20anime%20collection,your%20next%20anime%20to%20watch)) ([Shoko | Anime Management System](https://shokoanime.com/#:~:text=Shoko%20provides%20robust%20tools%20for,TMDB%20links%20per%20series%2C%20Shoko)). 우리 프로젝트는 이들에 비해 경량화된 단순 정리 도구로 출발하지만, 향후에는 FileBot의 유연성, Shoko의 정확성을 일부 도입하여 **가볍지만 똑똑한** 애니메이션 정리기로 발전시키고자 한다. 특히 FileBot이 제공하는 커맨드라인 인터페이스나 스케줄러 연동 기능도 고려해볼 수 있는데, 이는 파워유저들이 자동화된 작업에 활용할 수 있게 해준다.
- **커뮤니티 피드백 반영**: 오픈소스로 전환하여 사용자 커뮤니티의 의견을 수렴할 계획이 있다. 이를 통해 새로운 기능 요청이나 버그 리포트를 적극 받아 개선 주기를 짧게 가져간다. 예를 들어, 특정 국가별 제목이나 특별한 분류 기준(예: 방영 시즌별 폴더 등)에 대한 요구가 나오면 플러그인으로 실험해보고 정식 기능화할 수 있다. 또한 문서화(예: README, 사용 가이드)와 다국어 지원(PyQt의 번역 기능 활용)을 추가하여 사용자 경험을 향상시킨다.

以上の 개선 및 확장 계획을 통해, 프로젝트는 초기 버전에서 충족하지 못한 부분들을 지속적으로 보완하며 성장해나갈 것이다. 목표는 사용자에게 **안정적이고 편리한 애니메이션 파일 관리 도구**를 제공하는 것이며, 기술 트렌드와 사용자 요구에 맞춰 유연하게 진화하는 프로젝트로 유지하는 것이다.